{"version":3,"sources":["PathfindingVisualizer/Node/Node.js","PathfindingVisualizer/Popup.js","algorithms/helpers.js","algorithms/AStar.js","algorithms/greedybest.js","PathfindingVisualizer/PathfindingVisualizer.js","algorithms/dijkstra.js","App.js","reportWebVitals.js","index.js"],"names":["Node","props","row","col","isStart","isEnd","isWall","isHover","onMouseDown","onMouseUp","onMouseEnter","onMouseLeave","extra_class","hover","id","className","Popup","onClick","handleClose","content","manhattanDistance","node","target","Math","abs","sortNodes","unvisited","sort","a","b","cost","getUnvisitedNeighbours","grid","neighbours","push","length","filter","neighbour","isVisited","getShortestPath","endNode","shortestPath","cur","unshift","previousNode","getGHCosts","startNode","hCosts","gCosts","Infinity","findSmallestFCost","openSet","openSetValues","Object","values","smallest_node","val","getHCosts","PathfindingVisualizer","useState","setGrid","mouseIsPressed","setMouseIsPressed","reset","setReset","animation","setAnimation","popupOpen","setPopupOpen","addWalls","setAddsWalls","numRows","setNumRows","numCols","setNumCols","changeStart","setChangeStart","setStartNode","changeEnd","setChangeEnd","setEndNode","walls","setWalls","rows","i","cols","createGrid","useCallback","curRow","createNode","start","end","useEffect","new_grid","start_node","end_node","toString","animatePathFinding","visited_nodes","shortest_path_list","delayMultiplier","setTimeout","document","getElementById","animateShortestPath","shortest_path","updateGrid","concat","getNewGridWalls","newGrid","slice","newNode","find","start_end","j","getWallsArray","resetGrid","togglePopup","cancelChange","rel","href","visited","cur_node","pop","unvisited_neighbours","includes","dijkstra","closedSet","gCost","keys","AStar","greedyBestFirstSearch","style","marginTop","color","map","row_index","col_index","alert","handleMouseDown","handleMouseEnter","handleMouseLeave","handleMouseUp","marginBottom","fontSize","name","value","onChange","e","count","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.77a655e7.chunk.js","sourcesContent":["import React from 'react';\nimport \"./Node.css\";\n\nexport function Node(props) {\n    const {row, col, isStart, isEnd, isWall, isHover, onMouseDown, onMouseUp, onMouseEnter, onMouseLeave} = props;\n\n    const extra_class = isEnd ? 'node-end' : isStart ? 'node-start' : isWall ? 'node-wall' : '';\n    const hover = isHover ? 'node-hover' : '';\n\n    \n    return (\n        <div \n            id={`node-${row}-${col}`} \n            className={`node ${extra_class} ${hover}`}\n            onMouseDown={() => onMouseDown(row, col)}\n            onMouseEnter={() => onMouseEnter(row, col)}\n            onMouseLeave={() => onMouseLeave(row, col)}\n            onMouseUp={() => onMouseUp(row, col)}\n        ></div>\n    );\n}\n\n","import React from \"react\";\nimport \"./Popup.css\"\n \nexport const Popup = (props) => {\n  return (\n    <div className=\"popup-box\">\n      <div className=\"box\">\n        <span className=\"close-icon\" onClick={props.handleClose}>x</span>\n        {props.content}\n      </div>\n    </div>\n  );\n};\n ","//AStar heuristic\n//https://datascience.stackexchange.com/questions/20075/when-would-one-use-manhattan-distance-as-opposed-to-euclidean-distance\n//So in a nutshell: Manhattan distance generally works only if the points are arranged in the form of a grid and the problem which we are working on gives more priority to the distance between the points only along with the grids, but not the geometric distance.\nexport const manhattanDistance = (node, target) => {\n    return Math.abs(node.row-target.row) + Math.abs(node.col-target.col);\n}\n\n//Returns reverse ordered array of unvisited nodes by cost\nexport const sortNodes = (unvisited) => {\n    //Iterates through unvisited array and compares each pair of nodes\n    //If b - a > 0, swap position of b & a\n    unvisited.sort((a, b) => b.cost - a.cost);\n}\n\n//Returns a list of unvisited nodes surrounding the current node\nexport const getUnvisitedNeighbours = (node, grid) => {\n    const neighbours = [];\n    const {col, row} = node;\n    if (row > 0) {\n        neighbours.push(grid[row - 1][col]);\n    }\n    if (row < grid.length - 1) {\n        neighbours.push(grid[row + 1][col]);\n    }\n    if (col > 0) {\n        neighbours.push(grid[row][col - 1]);\n    }\n    if (col < grid[0].length - 1) {\n        neighbours.push(grid[row][col + 1]);\n    }\n    return neighbours.filter(neighbour => !neighbour.isVisited && !neighbour.isWall);\n}\n\n//Returns a list of the shortest path of nodes\n//Uses backtracking to go from endNode to startNode\nexport function getShortestPath(endNode) {\n    const shortestPath = [];\n    let cur = endNode;\n    while (cur) {\n        shortestPath.unshift(cur); //Add current node to start of shortestPath list\n        cur = cur.previousNode;\n    }\n\n    return shortestPath;\n}","import { getUnvisitedNeighbours, manhattanDistance } from \"./helpers\";\n\n// Returns an array of visited nodes (closed set) between startNode and endNode using A* with manhattan distance\nexport function AStar(grid, startNode, endNode) {\n    // Initialize Visited List\n    const closedSet = [];\n    // Initialize unvisited list\n    const openSet = {};\n\n    // gCost minimum distance from start node to current node\n    // hCost (heuristic cost) estimated cost to the end from the current node\n    const [gCosts, hCosts] = getGHCosts(startNode, endNode, grid)\n\n    startNode.cost = hCosts[startNode.id]; // Represents the fCost of start node\n    openSet[startNode.id] = startNode;\n\n    do {\n        const cur_node = findSmallestFCost(openSet, gCosts);\n        delete openSet[cur_node.id]\n        \n        // Update value of current node and append to visited list\n        cur_node.isVisited = true;\n        closedSet.push(cur_node);\n\n        // If endnode is found, terminate function\n        if (cur_node === endNode) {\n            return closedSet;\n        }\n\n\t\t// Check the neighbours of the current node\n        const unvisited_neighbours = getUnvisitedNeighbours(cur_node, grid);\n        for (const neighbour of unvisited_neighbours) {\n            const gCost = gCosts[cur_node.id] + 1;\n            if (gCost < gCosts[neighbour.id]) {\n                gCosts[neighbour.id] = gCost;\n                neighbour.cost = gCost + hCosts[neighbour.id]; // fCost\n                neighbour.previousNode = cur_node;\n                if (!openSet[neighbour.id]) {\n                    openSet[neighbour.id] = neighbour;\n                }\n            }\n        }\n    } while (Object.keys(openSet).length !== 0);\n    return closedSet;\n}\n\n//Gets gCosts (Infinity except for start) & hCosts relative to end node (manhattan distance)\nconst getGHCosts = (startNode, endNode, grid) => {\n    const hCosts = {};\n    const gCosts = {};\n\n    for (let row = 0; row < grid.length; ++row) {\n        for (let col = 0; col < grid[row].length; ++col) {\n            const node = grid[row][col];\n            hCosts[node.id] = manhattanDistance(endNode, node);\n            if (node === startNode) {\n                gCosts[node.id] = 0;\n            }\n            else {\n                gCosts[node.id] = Infinity;\n            }\n        }\n    }\n\treturn [gCosts, hCosts];\n};\n\nconst findSmallestFCost = (openSet, gCosts) => {\n    let openSetValues = Object.values(openSet)\n    let smallest_node = openSetValues[0];\n\tfor (const val of openSetValues) {\n\t\tif (\n            val.cost < smallest_node.cost ||\n            (val.cost === smallest_node.cost && gCosts[val.id] < gCosts[smallest_node.id])\n        ) {\n\t\t\tsmallest_node = val;\n        }\n\t}\n\treturn smallest_node;\n}","import { manhattanDistance, getUnvisitedNeighbours, sortNodes } from \"./helpers\";\n// Greedy best-first search algorithm\n// Returns an array of visited nodes (closed set) between startNode and endNode using manhattan distance as heuristic\nexport function greedyBestFirstSearch(grid, startNode, endNode) {\n\n    // hCost (heuristic cost) estimated cost to the end from the current node\n    // Saved under node.cost\n    getHCosts(endNode, grid)\n\n    // Initialize Visited List\n    const visited = [];\n    // Initialize unvisited list\n    const unvisited = [startNode];\n\n    do {\n        sortNodes(unvisited) //Sort the unvisited nodes by cost (reverse order)\n        const cur_node = unvisited.pop() //Get the lowest cost node\n        \n        // Update value of current node and append to visited list\n        cur_node.isVisited = true;\n        visited.push(cur_node);\n\n        // If endnode is found, terminate function\n        if (cur_node === endNode) {\n            return visited;\n        }\n\n\t\t// Check the neighbours of the current node\n        const unvisited_neighbours = getUnvisitedNeighbours(cur_node, grid);\n        for (const neighbour of unvisited_neighbours) {\n            if (!unvisited.includes(neighbour)) {\n                neighbour.previousNode = cur_node;\n                unvisited.push(neighbour);\n            }\n        }\n    } while (unvisited.length);\n    return visited;\n}\n\n//Gets hCosts relative to end node (manhattan distance)\nconst getHCosts = (endNode, grid) => {\n    for (let row = 0; row < grid.length; ++row) {\n        for (let col = 0; col < grid[row].length; ++col) {\n            const node = grid[row][col];\n            node.cost = manhattanDistance(endNode, node);\n        }\n    }\n};","import React, { useCallback, useEffect, useState } from 'react';\nimport { Node } from './Node/Node';\nimport { Popup } from './Popup';\nimport \"./PathfindingVisualizer.css\";\nimport { dijkstra } from \"../algorithms/dijkstra\";\nimport { getShortestPath } from \"../algorithms/helpers\";\nimport { AStar } from \"../algorithms/AStar\";\nimport {greedyBestFirstSearch} from \"../algorithms/greedybest\"\n\nconst NUMROWS = 25;\nconst NUMCOLS = 50;\nconst START_NODE_ROW = 12;\nconst START_NODE_COL = 5;\nconst END_NODE_ROW = 12;\nconst END_NODE_COL = 45;\nconst ANIMATION_SPEED = 12;\n\nexport function PathfindingVisualizer() {\n    //States for handling grid, animation, popup, mouse\n    const [grid, setGrid] = useState([]);\n    const [mouseIsPressed, setMouseIsPressed] = useState(false);\n    const [reset, setReset] = useState(false);\n    const [animation,setAnimation] = useState(false);\n    const [popupOpen, setPopupOpen] = useState(false);\n    const [addWalls, setAddsWalls] = useState(true);\n    \n    //States for handling special nodes, gride size\n    const [numRows, setNumRows] = useState(NUMROWS);\n    const [numCols, setNumCols] = useState(NUMCOLS);\n    const [changeStart, setChangeStart] = useState(false);\n    const [startNode, setStartNode] = useState({row:START_NODE_ROW, col:START_NODE_COL});\n    const [changeEnd, setChangeEnd] = useState(false);\n    const [endNode, setEndNode] = useState({row:END_NODE_ROW, col:END_NODE_COL});\n    const [walls, setWalls] = useState([]);\n\n    //For rows & column dropdown menus\n    const rows = [];\n    for(let i = 10; i<=30; i++){\n        rows.push(i);\n    }\n    const cols = [];\n    for(let i = 10; i<=70; i++){\n        cols.push(i);\n    }\n\n    //function for creating/updating the grid\n    //called whenever dependencies are changed\n    const createGrid = useCallback( () => {\n        const grid = [];\n        for (let row=0; row<numRows; ++row){\n            const curRow = [];\n            for (let col=0; col<numCols; ++col){\n                curRow.push(createNode(row, col, {start:startNode, end:endNode, walls:walls}));\n            }\n            grid.push(curRow);\n        }\n        return grid;\n    }, \n    [numRows, numCols, startNode, endNode, walls]\n    );\n\n    //set new grid any time function is changed\n    useEffect(() => {\n        const new_grid = createGrid();\n        setGrid(new_grid);\n    }, [createGrid]);\n\n    //Returns new node\n    const createNode = (row, col, {start, end, walls}={}) => {\n        let start_node = row === start.row && col === start.col;\n        let end_node = row === end.row && col === end.col;\n        return {\n            row,\n            col,\n            isStart : start_node,\n            isEnd: end_node,\n            isVisited : false,\n            isWall : walls.length && row<walls.length && col < walls[0].length && walls[row][col],\n            isHover : false,\n            previousNode : null,\n            cost: Infinity,\n            id: \"row\" + row.toString() + \"col\" + col.toString() // Unique permutation so that each node has its own string id\n        };\n    };\n\n    //Solves current grid using Dijkstra's Algorithm\n    const solveDijkstra = () => {\n        const start = grid[startNode.row][startNode.col];\n        const end = grid[endNode.row][endNode.col];\n        const visited_nodes = dijkstra(grid, start, end); //returns a list of visited nodes\n        const shortest_path_list = getShortestPath(end); //returns the shortest path from end node to start node\n        animatePathFinding(visited_nodes, shortest_path_list);\n        setAnimation(true);\n    };\n\n    //Solves current grid using A*\n    const solveAStar = () => {\n        const start = grid[startNode.row][startNode.col];\n        const end = grid[endNode.row][endNode.col];\n        const visited_nodes = AStar(grid, start, end); //returns a list of visited nodes\n        const shortest_path_list = getShortestPath(end); //returns the shortest path from end node to start node\n        animatePathFinding(visited_nodes, shortest_path_list, 1.5);\n        setAnimation(true);\n    };\n\n    //Solves current grid using greedy best-first search\n    const solveGreedyBestFirstSearch = () => {\n        const start = grid[startNode.row][startNode.col];\n        const end = grid[endNode.row][endNode.col];\n        const visited_nodes = greedyBestFirstSearch(grid, start, end); //returns a list of visited nodes\n        const shortest_path_list = getShortestPath(end); //returns the shortest path from end node to start node\n        animatePathFinding(visited_nodes, shortest_path_list, 2);\n        setAnimation(true);\n    };\n\n    //Animates Dijkstra's Algorithm\n    const animatePathFinding = (visited_nodes, shortest_path_list, delayMultiplier=1) => {\n        //Iterate through visited nodes\n        for(let i =0; i<visited_nodes.length; ++i){\n            /*\n            //Updating entire state is not efficient\n            setTimeout( () => {\n                const node = visited_nodes[i];                \n                const new_node = {...node, isAnimated: true};\n                grid[node.row][node.col] = new_node;\n                if(i%update_interval===0 || i===visited_nodes.length-1){\n                    setGrid(new_grid);\n                    new_grid = grid.slice();\n                }\n            }, i);*/\n\n            //Only update class of node of interest\n            setTimeout(() => {\n                const node = visited_nodes[i];\n                if(!node.isStart && !node.isEnd){\n                    document.getElementById(`node-${node.row}-${node.col}`).className =\n                    'node node-visited';\n                }\n              }, ANIMATION_SPEED * i * delayMultiplier);\n        }      \n        \n        //After animating the visited nodes, do the shortest path animation\n        setTimeout(() => {\n            animateShortestPath(shortest_path_list);\n        }, ANIMATION_SPEED * visited_nodes.length * delayMultiplier)\n    };\n\n    //Animates shortest path\n    const animateShortestPath = (shortest_path) => {\n        for(let i = 0; i < shortest_path.length; ++i){\n            setTimeout( () => {\n                const node = shortest_path[i];\n                if(!node.isStart && !node.isEnd){\n                    //Updating only the class to improve speed/fluidity of animation\n                    document.getElementById(`node-${node.row}-${node.col}`).className =\n                    'node node-shortest-path';\n                }\n                else if(i===shortest_path.length-1){\n                    setReset(true);\n                    setAnimation(false);\n                }\n            }, 50 * i);\n        }\n    };\n\n    //Coded like this to allow click once to place and click twice to release (must delete handleMouseUp)\n    //Handles all possible events that occur when mouse is clicked on a node\n    const handleMouseDown = (row, col) => {\n        //Updating start node\n        if(changeStart && !grid[row][col].isWall && !grid[row][col].isEnd){\n            let start_node = find('start');\n            grid[start_node[0]][start_node[1]].isStart = false;\n            setStartNode({row:row, col:col});\n            setChangeStart(false);\n        }\n        //Updating end node\n        else if (changeEnd && !grid[row][col].isWall && !grid[row][col].isStart){\n            let end_node = find('end');\n            grid[end_node[0]][end_node[1]].isEnd = false;\n            setEndNode({row:row, col:col});\n            setChangeEnd(false);\n        }\n        //Invalid node selected for new start/end node\n        else if (changeEnd || changeStart){\n            alert('Please choose another space');\n            return;\n        }\n        //Adding a wall\n        else if(!mouseIsPressed && !reset && !animation){\n            getNewGridWalls(grid, row, col);\n            const walls = getWallsArray();\n            setWalls(walls);\n        } \n        setMouseIsPressed(!mouseIsPressed);\n    };\n\n    //Handles scenarios for when mouse enters a node\n    const handleMouseEnter = (row, col) => {\n        //Changing background colour of node when hovering\n        //Hover for new start node\n        if(changeStart && !grid[row][col].isEnd && !grid[row][col].isWall){\n            updateGrid(\"node-hover-start\", row, col);\n        }\n        //Hover for new end node\n        else if(changeEnd && !grid[row][col].isStart && !grid[row][col].isWall){\n            updateGrid(\"node-hover-end\", row, col);\n        }\n        else{\n            //Hover for wall\n            if(!(mouseIsPressed || grid[row][col].isWall || grid[row][col].isStart || grid[row][col].isEnd|| grid[row][col].isVisited || reset || animation) && addWalls){\n                updateGrid(\"node-hover\", row, col);\n            }\n            //Hover for delete wall\n            else if (!addWalls && grid[row][col].isWall && !reset && !animation){\n                updateGrid(\"node-hover-red\", row, col);\n            }\n            //Adding a new wall\n            if (mouseIsPressed && addWalls && !reset && !animation) {\n                getNewGridWalls(grid, row, col);\n                const walls = getWallsArray();\n                setWalls(walls);\n            }\n        }        \n    };\n\n    //Handles scenarios for when mouse leaves a node\n    const handleMouseLeave = (row, col) => {\n        //Removing class added from hover\n        if(!(mouseIsPressed || grid[row][col].isWall || grid[row][col].isStart || grid[row][col].isEnd || grid[row][col].isVisited) ||\n            ((changeStart || changeEnd) && !grid[row][col].isStart && !grid[row][col].isEnd && !grid[row][col].isWall))\n        {\n            updateGrid(\"\", row, col);\n        }\n        //Changing previous 'hover class' if node is a wall\n        else if (grid[row][col].isWall){\n            updateGrid(\"node-wall\", row, col);\n        }\n        //Remove wall\n        if(mouseIsPressed && !addWalls && !reset && !animation) {\n            getNewGridWalls(grid, row, col);\n            const walls = getWallsArray();\n            setWalls(walls);\n        }\n    }\n    \n    //Enables click and hold to place/remove\n    //If want to click once to place and click again to stop placing, just delete this function (and its calls)\n    const handleMouseUp = (row, col) => {\n        setMouseIsPressed(false);\n        \n        if(!(addWalls||reset||animation)){\n            getNewGridWalls(grid, row, col);\n            const walls = getWallsArray();\n            setWalls(walls);\n        }\n    };\n\n    //Add extra node class to grid space for any hover effects\n    const updateGrid = (extra_class, row, col) => {\n        document.getElementById(`node-${row}-${col}`).className =\n        'node '.concat(extra_class);\n    }\n\n    //Not actually shallow copy since 2D array, each node object in each column points to original node from grid\n    //Function updated the isWall property for the space\n    const getNewGridWalls = (grid, row, col) => {\n        const newGrid = grid.slice();\n        const node = newGrid[row][col];\n        const newNode = {\n          ...node,\n          isWall: addWalls &&!node.isStart &&!node.isEnd,\n        };\n        newGrid[row][col] = newNode;\n    };\n\n    //Finds (row,col) of the start/end node <- specified by string\n    const find = (start_end) => {\n        for(let i = 0; i < grid.length; ++i){\n            for(let j = 0; j<grid[0].length; ++j){\n                if(grid[i][j].isStart && start_end==='start'){\n                    return [i, j];\n                }\n                else if (grid[i][j].isEnd && start_end==='end'){\n                    return [i, j];\n                }\n            }\n        }\n\n        return false;\n    }\n\n    //Returns 2D bool array of grid to determine wall locations \n    //Also updates any non start,end, or wall nodes to have no extra class\n    const getWallsArray = () => {\n        const walls = [];\n        for(let i = 0; i< grid.length; ++i){\n            walls[i] = [];\n            for(let j=0; j<grid[0].length; ++j){\n                walls[i][j] = grid[i][j].isWall;\n                if(!grid[i][j].isStart && !grid[i][j].isEnd && !grid[i][j].isWall){\n                    updateGrid(\"\", i, j);\n                }\n            }\n        }\n        return walls;\n    }\n\n    //Resets grid (maintaining walls and start/end node)\n    const resetGrid = () => {\n        const walls = getWallsArray();\n        setWalls(walls);\n        setReset(false);\n        setAddsWalls(true);\n        setPopupOpen(false);\n    }\n\n    //Resets grid including all walls\n    const resetAll = () => {\n        if(reset){\n            resetGrid();\n        }\n        setWalls([]);\n        setAddsWalls(true);\n        setPopupOpen(false);\n    }\n\n    //Toggles popup menu\n    const togglePopup = () => {\n        if(!animation) setPopupOpen(!popupOpen);\n    }\n\n    //Toggles wall setting (between add and destroy)\n    const toggleWalls = () => {\n        if(reset){\n            resetGrid();\n        }\n        setAddsWalls(!addWalls);\n        setPopupOpen(false);\n        setMouseIsPressed(false);\n        cancelChange();\n    }\n\n    //Updating grid to select new start node\n    const updateChangeStart = () => {\n        if(reset){\n            resetGrid();\n        }\n        cancelChange(); //Handling case where other node is being updated\n        setPopupOpen(false);\n        setChangeStart(true);\n        setChangeEnd(false);\n        setAddsWalls(true);\n        let start = find('start');\n        updateGrid(\"node-hover-start\", start[0], start[1]);\n    }\n\n    //Updating grid to select new end node\n    const updateChangeEnd = () => {\n        if(reset){\n            resetGrid();\n        }\n        cancelChange(); //Handling case where other node is being updated\n        setPopupOpen(false);\n        setChangeEnd(true);\n        setChangeStart(false);\n        setAddsWalls(true);\n        let end = find('end');\n        updateGrid(\"node-hover-end\", end[0], end[1]);\n    }\n\n    //Cancelling update start/end selection\n    const cancelChange = () => {\n        setChangeStart(false);\n        setChangeEnd(false);\n        let start = find('start');\n        updateGrid(\"node-start\", start[0], start[1]);\n        let end = find('end');\n        updateGrid(\"node-end\", end[0], end[1]);\n    }\n\n    //Updating number of rows\n    const updateRows = (e) => {        \n        setNumRows(e.target.value);\n        let count = 1;\n        if(startNode.row >= e.target.value){\n            //handle if (node is endNode) or (node is a wall)\n            if(e.target.value-count === endNode.row && startNode.col === endNode.col){\n                count++;\n            }\n            grid[e.target.value-count][startNode.col].isWall=false;\n            setStartNode({...startNode, row:e.target.value-count});\n        }\n        if (endNode.row >= e.target.value){\n            //handle if (node is endNode) or (node is a wall)\n            if((e.target.value-count === startNode.row || startNode.row >= e.target.value) && startNode.col === endNode.col){ //incude case where start and end are in same column\n                count++;\n            }\n            grid[e.target.value-count][endNode.col].isWall=false;\n            setEndNode({...endNode, row:e.target.value-count});\n        }\n        if(reset){\n            resetGrid();\n        }\n        else{\n            const walls = getWallsArray();\n            setWalls(walls);\n        }\n    }\n\n    //Updating number of columns\n    const updateCols = (e) => {        \n        setNumCols(e.target.value);\n        let count = 1;\n        if(startNode.col >= e.target.value){\n            //handle if (node is endNode) or (node is a wall)\n            if(e.target.value-count === endNode.col && startNode.row === endNode.row){\n                count++;\n            }\n            grid[startNode.row][e.target.value-count].isWall=false;\n            setStartNode({...startNode, col:e.target.value-count});\n        }\n        if (endNode.col >= e.target.value){\n            //handle if (node is endNode) or (node is a wall)\n            if((e.target.value-count === startNode.col || startNode.col >= e.target.value) && startNode.row === endNode.row){ //incude case where start and end are in same row\n                count++;\n            }\n            grid[endNode.row][e.target.value-count].isWall=false;\n            setEndNode({...endNode, col:e.target.value-count});\n        }\n        if(reset){\n            resetGrid();\n        }\n        else{\n            const walls = getWallsArray();\n            setWalls(walls);\n        }\n    }\n\n    return (\n        <div>\n            <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\"></link>\n            <button onClick={togglePopup} className=\"settings\"><span className=\"fa fa-gear\"></span></button>\n            <div className='header'>\n                {!animation && !reset && !(changeStart || changeEnd) &&\n                    <div>\n                        <button className=\"headerButton\" onClick={solveDijkstra}>Dijkstra's Algorithm</button>\n                        <button className = \"headerButton\" onClick={solveAStar}>A* Algorithm</button>\n                        <button className = \"headerButton\" onClick={solveGreedyBestFirstSearch}>Greedy Best-First Search</button>\n                    </div>\n                }\n                {reset && !(changeStart || changeEnd) && <button onClick={resetGrid}>Reset Grid</button>}\n                {(changeStart || changeEnd) &&\n                    <div>\n                        {changeStart && <h3 style={{marginTop:'0px', color:'green'}}>Select New Start Node</h3>} \n                        {changeEnd && <h3 style={{marginTop:'0px', color:'red'}}>Select New End Node</h3>} \n                        <button onClick={cancelChange}>Cancel</button>\n                    </div>\n                }\n                <br></br>\n            </div>\n\n            <div className='grid'>\n                {grid.map((row, row_index) => {\n                    return <div key = {row_index}>\n                        {row.map((node, col_index) => {\n                            const {row, col, isStart, isEnd, isWall, isHover} = node;\n                            return <Node \n                                        key = {col_index} \n                                        col= {col}\n                                        row = {row}\n                                        isStart = {isStart} \n                                        isEnd = {isEnd}\n                                        isWall = {isWall}\n                                        mouseIsPressed = {mouseIsPressed}\n                                        isHover = {isHover}\n                                        onMouseDown = {(row, col) => handleMouseDown(row, col)}\n                                        onMouseEnter = {(row, col) => handleMouseEnter(row, col)}\n                                        onMouseLeave = {(row, col) => handleMouseLeave(row, col)}\n                                        onMouseUp = {(row, col) => handleMouseUp(row, col)}\n                                    ></Node>\n                            })\n                        }\n                    </div>\n                })}\n            </div>\n            {popupOpen && <Popup\n                            content={<>\n                                    <div className=\"row\">\n                                        <div className=\"column\">\n                                            <b>Reset All</b> \n                                        </div>\n                                        <div className=\"column\">\n                                            <button onClick={resetAll}><span className={\"fa fa-refresh\"}></span></button> \n                                        </div>\n                                    </div>\n                                    <br></br>\n                                    <div className=\"row\">\n                                        <div className=\"column\">\n                                            {!addWalls?<b>Add Walls</b>:<b>Remove Walls</b>}\n                                        </div>\n                                        <div className=\"column\">\n                                            <button onClick={toggleWalls}><span className={!addWalls?\"fa fa-wrench\":\"fa fa-bomb\"}></span></button>  {/*style={{marginTop:\"20px\"}}*/}\n                                        </div>\n                                    </div>\n                                    <br></br>\n                                    <div className=\"row\">\n                                        <div className=\"column\">\n                                            <b>Grid Size</b>\n                                        </div>\n                                        <div className=\"column\">\n                                            <div className=\"row\" style={{marginBottom:\"10px\"}}>\n                                                <div className=\"column\">\n                                                    <b style={{fontSize:\"15px\"}}>Rows</b>\n                                                </div>\n                                                <div className=\"column\">\n                                                    <b style={{fontSize:\"15px\"}}>Columns</b>\n                                                </div>\n                                            </div>\n                                            <div className=\"row\">\n                                                <div className=\"column\">\n                                                <select name=\"row-select\" value={numRows} onChange={updateRows}>\n                                                    {rows.map( (i) => {\n                                                        return (<option key = {i} value = {i}>{i}</option>)\n                                                    })}\n                                                </select>\n                                                    </div>\n                                                    <div className=\"column\">\n                                                        <select name=\"col-select\" value={numCols} onChange={updateCols}>\n                                                    {cols.map( (i) => {\n                                                        return (<option key = {i} value = {i} >{i}</option>)\n                                                    })}\n                                                </select>\n                                                    </div>\n                                                \n                                            </div>                                            \n                                        </div>\n\n                                    </div>\n                                    <br></br>\n                                    <div className=\"row\">\n                                        <div className=\"column\">\n                                            <button onClick = {updateChangeStart}>Change Start Node</button> \n                                        </div>\n                                        <div className=\"column\">\n                                            <button onClick={updateChangeEnd}>Change End Node</button> \n                                        </div>\n                                    </div>\n                                    </>}\n                            handleClose={togglePopup}\n                            />\n            }\n        </div>\n    );\n}\n\n","import { sortNodes, getUnvisitedNeighbours } from \"./helpers\";\n\n//Returns an array of visited nodes between startNode and endNode using Dijstra's Algorithm\nexport function dijkstra(grid, startNode, endNode){\n    //if (!startNode || !endNode || startNode===endNode || !grid.length){\n    //    return false;\n    //}\n\n    //Initialize Visited List\n    const visited = [];\n    //Initialize unvisited list\n    const unvisited = [startNode];\n    startNode.cost = 0;\n\n    do {\n        sortNodes(unvisited) //Sort the unvisited nodes by cost (reverse order)\n        const cur_node = unvisited.pop() //Get the lowest cost node\n\n        // Update value of current node and append to visited list\n        cur_node.isVisited = true;\n        visited.push(cur_node);\n        \n        // If endnode is found, terminate function\n        if (cur_node === endNode) {\n            return visited\n        };\n\n        // Updates the nodes surrounding the current node to include the current node as the previous node\n        const unvisited_neighbours = getUnvisitedNeighbours(cur_node, grid);\n        for (const neighbour of unvisited_neighbours) {\n            if (!unvisited.includes(neighbour)) {\n                neighbour.previousNode = cur_node;\n                neighbour.cost = cur_node.cost + 1;\n                unvisited.push(neighbour);\n            }\n        }\n    } while (unvisited.length);\n    return visited;\n}","import './App.css';\nimport {PathfindingVisualizer} from \"./PathfindingVisualizer/PathfindingVisualizer\"\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}